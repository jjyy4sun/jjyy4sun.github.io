<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[什么是游戏引擎]]></title>
      <url>/archives/f4101fc3.html</url>
      <content type="html"><![CDATA[<p>既然要设计游戏引擎，所以我们首先得知道什么是游戏引擎。但是在了解游戏引擎的概念之前，我先探讨一下什么是游戏呢？</p>
<h2 id="什么是游戏"><a href="#什么是游戏" class="headerlink" title="什么是游戏"></a>什么是游戏</h2><p>现在我们说的游戏可能是比较狭隘的游戏了，只是单纯指video game，也就是我们运行在电子产品上的视频游戏。但是游戏这个词本身是一个比较宽泛的概念，在我们小时候科技还没还未发展，电子产品还没有兴起的时候，我们也是可以呼朋引伴的玩游戏，诸如丢手绢、跳皮筋、打沙包等等。我也称这些活动为游戏。所以什么是游戏呢？</p>
<p>我个人对游戏理解是：</p>
<ol>
<li>明确的规则</li>
<li>一个和多个参与其中的玩家</li>
<li>一个或是多个目的</li>
<li>玩家在规则下使用各种方法和策略到达目的</li>
</ol>
<p>但是人为什么会想去玩游戏呢，我把它称之为<strong><em>体验</em></strong>。<br>在游戏中把自己代入角色体会现实中无法得到的体验（沉浸式体验）；打磨技术完成挑战（学习精进体验）；交友和放松心情（温暖舒心体验）。</p>
<p>所以这就是游戏，它在我们的现实社会中扮演着非常重要的角色，使我们生活必不可少的元素。</p>
<h2 id="什么是游戏引擎"><a href="#什么是游戏引擎" class="headerlink" title="什么是游戏引擎"></a>什么是游戏引擎</h2><p>游戏是对现实世界的一个模拟，模拟世界的花花草草、高山大川、高楼大厦、车水马龙等等；还有对时间的模拟，随着时间的流逝，各种事物的状态就会改变；还有一些自然规律的模拟，比如一些物理理论：自由落体、流体力学、刚体力学等等。</p>
<p>这样一看游戏之间有很多共通点，这些共通点可以打包成一个模块供很多游戏使用，这其实就是一个游戏引擎的概念。</p>
<p>最早的游戏引擎是id Software开发DOOM时提出的，他们把软件的一些核心组件进行划分，使得其中一部分可以经由id soft授权使用。那么这个就是早期游戏引擎的概念了。</p>
<h3 id="游戏引擎的多样性"><a href="#游戏引擎的多样性" class="headerlink" title="游戏引擎的多样性"></a>游戏引擎的多样性</h3><p>首先游戏有不同的类型，所以不同游戏类型对游戏引擎的要求也不一样。就拿图形渲染来说，渲染室内和渲染广阔场景要求是不一样的。而且不仅是游戏类型导致的游戏引擎的多样性，硬件平台也是其中的因素，不同游戏引擎可能针对不同的硬件平台优化力度和偏向不同。所以通用的游戏引擎往往在性能表现上吃亏，因而设计出一款可以制作任何游戏的引擎可以说是天方夜谭。</p>
<h3 id="现有知名游戏引擎"><a href="#现有知名游戏引擎" class="headerlink" title="现有知名游戏引擎"></a>现有知名游戏引擎</h3><ol>
<li>Unreal 非常全能的游戏引擎，支持可视化开发，几乎可以完成任何FPS和第三人称的3D游戏。</li>
<li>unity3D  几乎兼容所有的平台，易于学习和上手。</li>
<li>CryEngine 让你的游戏更美丽，输出非常优质的画面。</li>
<li>RAGE 复杂人工智能管理，可以去GTAV体验一下。</li>
</ol>
<p>还有好多非常优秀的游戏引擎，在这里就不一一举例了。</p>
<h2 id="运行时引擎架构"><a href="#运行时引擎架构" class="headerlink" title="运行时引擎架构"></a>运行时引擎架构</h2><p><img src="/img/gameEngineArc.png" alt="arc"></p>
<p>此图是出自《游戏引擎结构》这本书，它非常全面的为我们展示了游戏引擎的各个组件的划分和层级关系。</p>
<p>对于硬件、驱动、操作系统都不是游戏引擎主要关注的部分，但是不同平台的游戏引擎设计思路还是有一定区别的，咱们下按下不表。</p>
<h3 id="第三方软件开发包和中间件"><a href="#第三方软件开发包和中间件" class="headerlink" title="第三方软件开发包和中间件"></a>第三方软件开发包和中间件</h3><ul>
<li>数据结构及算法：STL、Boost、Loki。</li>
<li>图形：硬件接口库OpenGL/DirectX、libgcm、Edge</li>
<li>碰撞和物理：Havok、PhysX、ODE</li>
<li>动画：Granny、Havok Animation、Edge</li>
<li>人工智能： Kynapse</li>
<li>生物力学角色模型：Endorphin和Euphoria</li>
</ul>
<h3 id="平台独立层"><a href="#平台独立层" class="headerlink" title="平台独立层"></a>平台独立层</h3><p>包装常用的标准C语言库、操作系统调用以及其他基础API，保证封装的接口在不同的平台上都一样。</p>
<h3 id="核心系统"><a href="#核心系统" class="headerlink" title="核心系统"></a>核心系统</h3><ul>
<li>单元测试</li>
<li>数学库</li>
<li>内存管理</li>
</ul>
<p>一些实用性软件集合。</p>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>为各种各样的资源：贴图、网格、音频、字幕等资源提供一个统一的管理入库。</p>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>游戏引擎中最大最复杂的一个组件之一。</p>
<p>低阶渲染器：实用各种图形设备接口DirectX和OpenGL等，摄像机、光照几何图元的提交。<br>场景剔除与优化：空间剖析<br>视觉效果：粒子效果、动态阴影、HDR、FSAA等<br>前端：HUD、fMV、IGC、内置菜单</p>
<h3 id="剖析和调试工具"><a href="#剖析和调试工具" class="headerlink" title="剖析和调试工具"></a>剖析和调试工具</h3><p>内存以及性能统计工具</p>
<h3 id="碰撞和物理"><a href="#碰撞和物理" class="headerlink" title="碰撞和物理"></a>碰撞和物理</h3><ul>
<li>力以及约束</li>
<li>刚体</li>
<li>物理碰撞</li>
</ul>
<p>Havok和PhysX</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul>
<li>刚体层次结构动画</li>
<li>骨骼动画</li>
<li>每顶点D动画</li>
</ul>
<h3 id="人体接口设备"><a href="#人体接口设备" class="headerlink" title="人体接口设备"></a>人体接口设备</h3><ul>
<li>键盘鼠标</li>
<li>手柄</li>
<li>其他游戏设备</li>
</ul>
<p>检测输入和判断一下复杂的组合输入</p>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>管理游戏里面的音频文件</p>
<h3 id="在线多人"><a href="#在线多人" class="headerlink" title="在线多人"></a>在线多人</h3><ul>
<li>单屏多人</li>
<li>切割屏多人</li>
<li>网络多人</li>
<li>大型多人在线游戏</li>
</ul>
<h3 id="游戏基础系统"><a href="#游戏基础系统" class="headerlink" title="游戏基础系统"></a>游戏基础系统</h3><p>游戏性指游戏内进行的活动、支配游戏世界的规则、玩家新角色能力、其他玩家的能力和玩家长期和短期的目标。<br>可以利用一些开发效率较高的脚本语言来设计实现。</p>
<h3 id="个别游戏系统"><a href="#个别游戏系统" class="headerlink" title="个别游戏系统"></a>个别游戏系统</h3><p>这个是在游戏引擎没有包含，而游戏需要，所以为了个别游戏定制的系统。</p>
<h2 id="工具和资产管道"><a href="#工具和资产管道" class="headerlink" title="工具和资产管道"></a>工具和资产管道</h2><p>游戏中存在各种数据，都是可以使用专有的工具设计出来的，但是这些数据包含了工具本身一些数据，所以游戏引擎不能直接使用，所以可以利用资产管道把这些数据处理成游戏引擎可以使用的数据。</p>
<p>还有一种工具就是世界编辑器，可以让玩家自定义游戏世界。</p>
<p>工具可以独立架构，或是和运行时库使用同样的框架构建。</p>
]]></content>
      
        <categories>
            
            <category> 游戏引擎 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游戏引擎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[游戏引擎概述]]></title>
      <url>/archives/67e448db.html</url>
      <content type="html"><![CDATA[<p>本人一直对游戏引擎很感兴趣，而且现在入职的公司是做gpu，所以趁此机会系统的学习一下游戏引擎的知识。</p>
<p>本篇是提炼了一下概念，制作了一个思维导图：</p>
<p><img src="/img/gameEngine.png" alt="pic"></p>
<p>接下来的几篇博文将逐一细致的谈论上述图片提及的知识点。</p>
]]></content>
      
        <categories>
            
            <category> 游戏引擎 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游戏引擎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[杨辉三角打印队列实现]]></title>
      <url>/archives/cf460c9e.html</url>
      <content type="html"><![CDATA[<pre><code>void printYanghui(int n){
    std::queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i++)
    {
        int m,s;
        q.push(0);//为了计算末尾的1
        for (int k = 1; k &lt;= i; ++k)
        {
            if(1==k){
                m = 1;//第一个数都是1，所以不用入队列
            }
            s = q.front();
            q.pop();
            q.push(m + s);

            std::cout &lt;&lt; m &lt;&lt; &quot; &quot;;
            m = s;

        }

        std::cout &lt;&lt; std::endl;
    }
}
</code></pre><hr>
<p>打印10行的结果：    </p>
<blockquote>
<p>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1<br>1 6 15 20 15 6 1<br>1 7 21 35 35 21 7 1<br>1 8 28 56 70 56 28 8 1<br>1 9 36 84 126 126 84 36 9 1 </p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 面试算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随机数]]></title>
      <url>/archives/7c9eec8d.html</url>
      <content type="html"><![CDATA[<h1 id="如何在c-产生随机数"><a href="#如何在c-产生随机数" class="headerlink" title="如何在c++产生随机数"></a>如何在c++产生随机数</h1><p>在 c++中要实现随机数生成，我们要使用 rand()和srand()两个函数来完成。但是rand()是用<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/5544515?fr=aladdin" target="_blank" rel="external">线性同余法</a>实现的，所以产生的不是真正的随机数。</p>
<h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>单纯的rand()会返回一个0至RAND_MAX之间的随机数值,不过rand()是一次性的，因为系统默认的随机数种子为1，只要随机数种子不变，其生成的随机数序列就不会改变。</p>
<h2 id="srand"><a href="#srand" class="headerlink" title="srand()"></a>srand()</h2><p>srand()可用来设置rand()产生随机数时的随机数种子。通过设置不同的种子，我们可以获取不同的随机数序列。可以利用srand((unsigned int)(time(NULL))的方法，利用系统时钟，产生不同的随机数种子。</p>
<pre><code># include &lt;iostream&gt;
# include &lt;cstdlib&gt;
# include &lt;ctime&gt;
using namespace std;
int main()
{
    srand((unsigned)time(NULL));
    for(int i=0;i&lt;10;i++)
    cout&lt;&lt;rand()&lt;&lt;&#39; &#39;;
    return 0;
}
</code></pre><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><ul>
<li>取得(0,x)的随机整数：rand()%x；</li>
<li>取得[a,b)的随机整数：rand()%(b-a)+a；</li>
<li>取得[a,b]的随机整数：rand()%(b-a+1)+a；</li>
<li>取得(a,b]的随机整数：rand()%(b-a)+a+1；</li>
<li>取得0-1之间的浮点数：rand()/double(RAND_MAX)。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> c/c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01背包]]></title>
      <url>/archives/e0e8ca7f.html</url>
      <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="01背包描述"><a href="#01背包描述" class="headerlink" title="01背包描述"></a>01背包描述</h2><p>有N件物品和一个容量为V的背包。第 i 件物品的重量是c[i],价值为 w[i]。求解将那些物品装入背包可以使价值最大。</p>
<p>但是为什么会叫它01背包呢？其实这里的01指的是状态，当把物品装进去那么状态就是1，不装就是0.</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>01背包问题其实就是动态规划，那么解决动态规划的思路就一个，找到状态转移方程即可。</p>
<p>那么01背包的状态转移方程是：</p>
<blockquote>
<p>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</p>
</blockquote>
<p>dp[i][j]表示的就是第i个物品，重量为j的物品价值。那么从哪几个状态可以转化到这个状态呢。有两个:</p>
<ol>
<li>dp[i-1][j]不把第i件物品放入背包。</li>
<li>dp[i-1][j-weight[i]]+value[i]把第i件物品放入背包。</li>
</ol>
<p>多说无益，直接上代码：</p>
<pre><code>int dp[100][100] = {0};//记录每种情况下物品总价值
int wight[100];//每种物品的重量
int value[100];//每种物品的价值

for(int i=1;i&lt;=50;i++)//50种物品
{
    for(int j = 0;j&lt;=80;j++)//背包可称重80
    {
        if(j&gt;weight[i])
        {
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
        }
        else
        {
            dp[i][j] = dp[i-1][j];
        }
    }
}

reuturn dp[50][80];
</code></pre><p>但是我们可以发现我们定义了一个二维数组，如果数据很大时，对内存的开销极大。为此我们可以使用滚动数组，简而言之滚动数组就是用后一个状态覆盖前一个状态。</p>
<pre><code>for(i=1; i&lt;=n; i++)
{
    for(j = m;j&gt;=wight[i];j--)
    {
        dp[j] = max(dp[j],dp[j-weight[i]]+value[i]);
    }
}
reuturn dp[m];
</code></pre><p>出看可能有点难以理解，不过仔细研究发现内层循环每一次循环都是放第 i个物品的过程。每一次循环后得到一个一维数组 dp[m]。每个数组元素保存的就是放入第i个物品后的物品总价值。所以每次循环利用这个一维数组，滚动变成了二维数组。</p>
<p>其实还有<strong><em>完全背包</em></strong>和<strong><em>多重背包</em></strong>的问题，这里不做细说。</p>
]]></content>
      
        <categories>
            
            <category> 经典算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CMake简介]]></title>
      <url>/archives/aac1e10b.html</url>
      <content type="html"><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="什么是-CMake"><a href="#什么是-CMake" class="headerlink" title="什么是 CMake"></a>什么是 CMake</h2><p>由于存在各种各样不同的平台，所以就产生了各种各样的 makefile 文件。当我们想使软件可以跨平台，那么我们不得不对每个平台编写一个 Makefile。</p>
<p>这时候 cmake 就应运而生，它允许开发者只编写一个名为 CMakelists.txt的文件，就可以执行 cmake 后自动生成对应平台的 Makefile 文件。</p>
<p>执行起来也非常简单，只需要 cmake PATH 即可，其中 PATH 就是 CMakeLists.txt 的路径。</p>
<h2 id="如何编写-CMakeLists-txt文件"><a href="#如何编写-CMakeLists-txt文件" class="headerlink" title="如何编写 CMakeLists.txt文件"></a>如何编写 CMakeLists.txt文件</h2><p>有上述可知，编写 CMakeLists.txt 成了使用 cmake 的关键。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本的要求
cmake_minimum_required (VERSION 2.8)

#项目信息
project(Demo)

#指定生成的目标
add_executable(Demo main.c)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>#号是用来注释的。</p>
<h3 id="多个目录及源文件"><a href="#多个目录及源文件" class="headerlink" title="多个目录及源文件"></a>多个目录及源文件</h3><p>我们在实际的生产环境中一般都是有多个目录和源文件的项目。所以如何利用 CMakeLists.txt 来构建整个项目才是学习的重点。</p>
<p>假如我们的项目目前有main.c、libfunc.c、libfunc.h三个文件。那么我们的 CMakeLists.txt 就可以这么写。</p>
<pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)

#项目信息
project (Demo2)

#指定生成目标
add_executable(Demo main.c libfunc.c)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上我们只是在生成目标时，将 libfunc.c 加入而已。那么当我们有很多源文件那么一条一条的加入一定不是一个明智的做法。幸好我可以使用<code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code>来定义一个需要加入源文件的目录，所以我们可以将上面的 CMakeLists.txt 修改为。</p>
<pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)
#项目信息
project (Demo2)
#创建 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
#指定生成目标
add_executable(Demo ${DIR_SRCS})
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>利用了 aux_source_directory 来定义了一个名为DIR_SRCS的变量，他的值为’.’。这样在生成目标的时候就可以不当前目录的所有源文件包含。</p>
<p>如果我们的目录结构是 main.c 在根目录，而函数库定义的源文件libfunc.c 在 lib 目录下那又该如何编写 CMakeLists.txt 呢？<br>这时就该为每个目录编写一个 CMakeLists.txt 了。</p>
<p>所以首先根目录的CMakeLists.txt：</p>
<pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)
#项目信息
project (Demo3)
#创建 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
#添加  lib 子目录
add_subdirectory(lib)
#指定生成目标
add_executable(Demo main.cc)
#添加链接库
target_link_libraries(Demo lib)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看到了添加 lib 子目录add_subdirectory(lib)的命令。<br>然后就是 target_link_libraries（Demo lib）将 lib 库链接到最终生成的目标中。</p>
<p>接下来我们在就可以在 lib 目录下编写CMakeLists.txt 了。</p>
<pre><code>#创建 DIR_LIB_SRCS 变量
aux_source_directory(. DIR_LIB_SRCS)
#生成链接库
add_library ( lib ${DIR_LIB_SRCS})
</code></pre><p>可以看到的是我们使用了 add_library 将lib 生成静态链接库。</p>
<p>掌握上述的知识点基本上就可以满足一般的需求了。但是 cmake 还是提供了一些更自由的方式。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>设置版本号</p>
<pre><code>set (Tutorial_VERSION_MAJOR 1)
set (Tutorial_VERSION_MINOR 0)

configure_file(
                                &quot;${PROJECT_SOURCE_DIR}/Config.h.in&quot;
                                &quot;${PROJECT_SOURCE_DIR}/Config.h&quot;
                                )
</code></pre><p>在 Config.h.in 中定义：<br>在 Config.h.in 中定义：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @ Tutorial_VERSION_MINOR@
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样 cmake 就会自动生成一个 Config.h 文件。<br>但是需要将 Config.h包含在要使用版本号的地方。然后就可以在源代码中使用Tutorial_VERSION_MAJOR和Tutorial_VERSION_MINOR了。</p>
<p>还可使用 <code>include_directories(...)</code>指定头文件目录。</p>
<p>设置选项：</p>
<pre><code>option(USE_MYLIB
                &quot;Use my own lib function&quot; ON)
if (USE_MYLIB)
  include_directories (&quot;${PROJECT_SOURCE_DIR}/lib&quot;)
  add_subdirectory (lib)
  set (EXTRA_LIBS ${EXTRA_LIBS} lib)
endif (USE_MYLIB)
</code></pre><p>在源代码中添加：</p>
<pre><code>#ifdef USE_MYLIB
  #include &quot;lib/libfunc.h&quot;
#else
</code></pre><h3 id="gdb-相关设置"><a href="#gdb-相关设置" class="headerlink" title="gdb 相关设置"></a>gdb 相关设置</h3><pre><code>set(CMAKE_BUILD_TYPE &quot;Debug&quot;)
set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV{CXXFLAGS} -O0 -Wall -g -ggdb&quot;)
set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV{CXXFLAGS} -O3 -Wall&quot;)
</code></pre><p>cmake 能做的还有很多诸如安装、测试、打包等操作。而且可以在 cmake 中定义函数和宏定义。你可以在<a href="https://cmake.org/" target="_blank" rel="external">cmake 官方网站</a>学习更多。</p>
]]></content>
      
        <categories>
            
            <category> 编程实用技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络爬虫介绍]]></title>
      <url>/archives/6adcba8e.html</url>
      <content type="html"><![CDATA[<h3 id="什么是网络爬虫"><a href="#什么是网络爬虫" class="headerlink" title="什么是网络爬虫?"></a>什么是网络爬虫?</h3><p>简而言之爬虫就是一个自动抓取网页信息的程序或脚本。<br>当然，抓取也不是漫无目的的。爬虫设计者会制定一些规则，从而使得<br>爬虫抓取出来信息具有意义和使用价值。</p>
<h3 id="爬虫的构成"><a href="#爬虫的构成" class="headerlink" title="爬虫的构成"></a>爬虫的构成</h3><p>控制节点、爬虫节点、资源库三部分构成。</p>
<ol>
<li>控制节点：根据 URL 链接来分配线程，并调用爬虫节点进行具体爬行。</li>
<li>爬虫节点：下载网页、处理文本、过滤链接、分析数据等。</li>
<li>用来存储下载下来的数据，并生成索引供用户检索。</li>
</ol>
<hr>
<h3 id="爬虫分类"><a href="#爬虫分类" class="headerlink" title="爬虫分类"></a>爬虫分类</h3><h4 id="通用爬虫"><a href="#通用爬虫" class="headerlink" title="通用爬虫"></a>通用爬虫</h4><p>  通用网络爬虫又称全网爬虫，爬行对象从一些种子 URL 扩充到整个 Web。主要用于搜索引擎。<br>通用网络爬虫的结构大致可以分为页面爬行模块 、页面分析模块、链接过滤模块、页面数据库、URL 队列、初始 URL 集合几个部分。为提高工作效率，通用网络爬虫会采取一定的爬行策略。</p>
<h4 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h4><p>  又称主题网络爬虫，选择性地爬行那些与预先定义好的主题相关页面的网络爬虫。聚焦网络爬虫和通用网络爬虫相比，增加了链接评价模块以及内容评价模块。</p>
<h4 id="增量爬虫"><a href="#增量爬虫" class="headerlink" title="增量爬虫"></a>增量爬虫</h4><p>  增量式网络爬虫是指对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。</p>
<h4 id="深度爬虫"><a href="#深度爬虫" class="headerlink" title="深度爬虫"></a>深度爬虫</h4><p> Web 页面按存在方式可以分为表层网页和深层网页。表层网页是指传统搜索引擎可以索引的页面，以超链接可以到达的静态网页为主构成的 Web 页面。Deep Web 是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的 Web 页面。自动填写表单，爬取深层网页是深度爬虫的任务。</p>
]]></content>
      
        <categories>
            
            <category> 编程实用技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
