<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[随机数]]></title>
      <url>/archives/7c9eec8d.html</url>
      <content type="html"><![CDATA[<h1 id="如何在c-产生随机数"><a href="#如何在c-产生随机数" class="headerlink" title="如何在c++产生随机数"></a>如何在c++产生随机数</h1><p>在 c++中要实现随机数生成，我们要使用 rand()和srand()两个函数来完成。但是rand()是用<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/5544515?fr=aladdin" target="_blank" rel="external">线性同余法</a>实现的，所以产生的不是真正的随机数。</p>
<h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>单纯的rand()会返回一个0至RAND_MAX之间的随机数值,不过rand()是一次性的，因为系统默认的随机数种子为1，只要随机数种子不变，其生成的随机数序列就不会改变。</p>
<h2 id="srand"><a href="#srand" class="headerlink" title="srand()"></a>srand()</h2><p>srand()可用来设置rand()产生随机数时的随机数种子。通过设置不同的种子，我们可以获取不同的随机数序列。可以利用srand((unsigned int)(time(NULL))的方法，利用系统时钟，产生不同的随机数种子。</p>
<pre><code># include &lt;iostream&gt;
# include &lt;cstdlib&gt;
# include &lt;ctime&gt;
using namespace std;
int main()
{
    srand((unsigned)time(NULL));
    for(int i=0;i&lt;10;i++)
    cout&lt;&lt;rand()&lt;&lt;&#39; &#39;;
    return 0;
}
</code></pre><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><ul>
<li>取得(0,x)的随机整数：rand()%x；</li>
<li>取得[a,b)的随机整数：rand()%(b-a)+a；</li>
<li>取得[a,b]的随机整数：rand()%(b-a+1)+a；</li>
<li>取得(a,b]的随机整数：rand()%(b-a)+a+1；</li>
<li>取得0-1之间的浮点数：rand()/double(RAND_MAX)。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> c/c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01背包]]></title>
      <url>/archives/e0e8ca7f.html</url>
      <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="01背包描述"><a href="#01背包描述" class="headerlink" title="01背包描述"></a>01背包描述</h2><p>有N件物品和一个容量为V的背包。第 i 件物品的重量是c[i],价值为 w[i]。求解将那些物品装入背包可以使价值最大。</p>
<p>但是为什么会叫它01背包呢？其实这里的01指的是状态，当把物品装进去那么状态就是1，不装就是0.</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>01背包问题其实就是动态规划，那么解决动态规划的思路就一个，找到状态转移方程即可。</p>
<p>那么01背包的状态转移方程是：</p>
<blockquote>
<p>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</p>
</blockquote>
<p>dp[i][j]表示的就是第i个物品，重量为j的物品价值。那么从哪几个状态可以转化到这个状态呢。有两个:</p>
<ol>
<li>dp[i-1][j]不把第i件物品放入背包。</li>
<li>dp[i-1][j-weight[i]]+value[i]把第i件物品放入背包。</li>
</ol>
<p>多说无益，直接上代码：</p>
<pre><code>int dp[100][100] = {0};//记录每种情况下物品总价值
int wight[100];//每种物品的重量
int value[100];//每种物品的价值

for(int i=1;i&lt;=50;i++)//50种物品
{
    for(int j = 0;j&lt;=80;j++)//背包可称重80
    {
        if(j&gt;weight[i])
        {
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
        }
        else
        {
            dp[i][j] = dp[i-1][j];
        }
    }
}

reuturn dp[50][80];
</code></pre><p>但是我们可以发现我们定义了一个二维数组，如果数据很大时，对内存的开销极大。为此我们可以使用滚动数组，简而言之滚动数组就是用后一个状态覆盖前一个状态。</p>
<pre><code>for(i=1; i&lt;=n; i++)
{
    for(j = m;j&gt;=wight[i];j--)
    {
        dp[j] = max(dp[j],dp[j-weight[i]]+value[i]);
    }
}
reuturn dp[m];
</code></pre><p>出看可能有点难以理解，不过仔细研究发现内层循环每一次循环都是放第 i个物品的过程。每一次循环后得到一个一维数组 dp[m]。每个数组元素保存的就是放入第i个物品后的物品总价值。所以每次循环利用这个一维数组，滚动变成了二维数组。</p>
<p>其实还有<strong><em>完全背包</em></strong>和<strong><em>多重背包</em></strong>的问题，这里不做细说。</p>
]]></content>
      
        <categories>
            
            <category> 经典算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CMake简介]]></title>
      <url>/archives/aac1e10b.html</url>
      <content type="html"><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="什么是-CMake"><a href="#什么是-CMake" class="headerlink" title="什么是 CMake"></a>什么是 CMake</h2><p>由于存在各种各样不同的平台，所以就产生了各种各样的 makefile 文件。当我们想使软件可以跨平台，那么我们不得不对每个平台编写一个 Makefile。</p>
<p>这时候 cmake 就应运而生，它允许开发者只编写一个名为 CMakelists.txt的文件，就可以执行 cmake 后自动生成对应平台的 Makefile 文件。</p>
<p>执行起来也非常简单，只需要 cmake PATH 即可，其中 PATH 就是 CMakeLists.txt 的路径。</p>
<h2 id="如何编写-CMakeLists-txt文件"><a href="#如何编写-CMakeLists-txt文件" class="headerlink" title="如何编写 CMakeLists.txt文件"></a>如何编写 CMakeLists.txt文件</h2><p>有上述可知，编写 CMakeLists.txt 成了使用 cmake 的关键。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本的要求
cmake_minimum_required (VERSION 2.8)

#项目信息
project(Demo)

#指定生成的目标
add_executable(Demo main.c)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>#号是用来注释的。</p>
<h3 id="多个目录及源文件"><a href="#多个目录及源文件" class="headerlink" title="多个目录及源文件"></a>多个目录及源文件</h3><p>我们在实际的生产环境中一般都是有多个目录和源文件的项目。所以如何利用 CMakeLists.txt 来构建整个项目才是学习的重点。</p>
<p>假如我们的项目目前有main.c、libfunc.c、libfunc.h三个文件。那么我们的 CMakeLists.txt 就可以这么写。</p>
<pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)

#项目信息
project (Demo2)

#指定生成目标
add_executable(Demo main.c libfunc.c)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上我们只是在生成目标时，将 libfunc.c 加入而已。那么当我们有很多源文件那么一条一条的加入一定不是一个明智的做法。幸好我可以使用<code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code>来定义一个需要加入源文件的目录，所以我们可以将上面的 CMakeLists.txt 修改为。</p>
<pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)
#项目信息
project (Demo2)
#创建 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
#指定生成目标
add_executable(Demo ${DIR_SRCS})
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>利用了 aux_source_directory 来定义了一个名为DIR_SRCS的变量，他的值为’.’。这样在生成目标的时候就可以不当前目录的所有源文件包含。</p>
<p>如果我们的目录结构是 main.c 在根目录，而函数库定义的源文件libfunc.c 在 lib 目录下那又该如何编写 CMakeLists.txt 呢？<br>这时就该为每个目录编写一个 CMakeLists.txt 了。</p>
<p>所以首先根目录的CMakeLists.txt：</p>
<pre class="line-numbers language-CMake"><code class="language-CMake">#CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)
#项目信息
project (Demo3)
#创建 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
#添加  lib 子目录
add_subdirectory(lib)
#指定生成目标
add_executable(Demo main.cc)
#添加链接库
target_link_libraries(Demo lib)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看到了添加 lib 子目录add_subdirectory(lib)的命令。<br>然后就是 target_link_libraries（Demo lib）将 lib 库链接到最终生成的目标中。</p>
<p>接下来我们在就可以在 lib 目录下编写CMakeLists.txt 了。</p>
<pre><code>#创建 DIR_LIB_SRCS 变量
aux_source_directory(. DIR_LIB_SRCS)
#生成链接库
add_library ( lib ${DIR_LIB_SRCS})
</code></pre><p>可以看到的是我们使用了 add_library 将lib 生成静态链接库。</p>
<p>掌握上述的知识点基本上就可以满足一般的需求了。但是 cmake 还是提供了一些更自由的方式。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>设置版本号</p>
<pre><code>set (Tutorial_VERSION_MAJOR 1)
set (Tutorial_VERSION_MINOR 0)

configure_file(
                                &quot;${PROJECT_SOURCE_DIR}/Config.h.in&quot;
                                &quot;${PROJECT_SOURCE_DIR}/Config.h&quot;
                                )
</code></pre><p>在 Config.h.in 中定义：<br>在 Config.h.in 中定义：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @ Tutorial_VERSION_MINOR@
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样 cmake 就会自动生成一个 Config.h 文件。<br>但是需要将 Config.h包含在要使用版本号的地方。然后就可以在源代码中使用Tutorial_VERSION_MAJOR和Tutorial_VERSION_MINOR了。</p>
<p>还可使用 <code>include_directories(...)</code>指定头文件目录。</p>
<p>设置选项：</p>
<pre><code>option(USE_MYLIB
                &quot;Use my own lib function&quot; ON)
if (USE_MYLIB)
  include_directories (&quot;${PROJECT_SOURCE_DIR}/lib&quot;)
  add_subdirectory (lib)
  set (EXTRA_LIBS ${EXTRA_LIBS} lib)
endif (USE_MYLIB)
</code></pre><p>在源代码中添加：</p>
<pre><code>#ifdef USE_MYLIB
  #include &quot;lib/libfunc.h&quot;
#else
</code></pre><h3 id="gdb-相关设置"><a href="#gdb-相关设置" class="headerlink" title="gdb 相关设置"></a>gdb 相关设置</h3><pre><code>set(CMAKE_BUILD_TYPE &quot;Debug&quot;)
set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV{CXXFLAGS} -O0 -Wall -g -ggdb&quot;)
set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV{CXXFLAGS} -O3 -Wall&quot;)
</code></pre><p>cmake 能做的还有很多诸如安装、测试、打包等操作。而且可以在 cmake 中定义函数和宏定义。你可以在<a href="https://cmake.org/" target="_blank" rel="external">cmake 官方网站</a>学习更多。</p>
]]></content>
      
        <categories>
            
            <category> 编程实用技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络爬虫介绍]]></title>
      <url>/archives/6adcba8e.html</url>
      <content type="html"><![CDATA[<h3 id="什么是网络爬虫"><a href="#什么是网络爬虫" class="headerlink" title="什么是网络爬虫?"></a>什么是网络爬虫?</h3><p>简而言之爬虫就是一个自动抓取网页信息的程序或脚本。<br>当然，抓取也不是漫无目的的。爬虫设计者会制定一些规则，从而使得<br>爬虫抓取出来信息具有意义和使用价值。</p>
<h3 id="爬虫的构成"><a href="#爬虫的构成" class="headerlink" title="爬虫的构成"></a>爬虫的构成</h3><p>控制节点、爬虫节点、资源库三部分构成。</p>
<ol>
<li>控制节点：根据 URL 链接来分配线程，并调用爬虫节点进行具体爬行。</li>
<li>爬虫节点：下载网页、处理文本、过滤链接、分析数据等。</li>
<li>用来存储下载下来的数据，并生成索引供用户检索。</li>
</ol>
<hr>
<h3 id="爬虫分类"><a href="#爬虫分类" class="headerlink" title="爬虫分类"></a>爬虫分类</h3><h4 id="通用爬虫"><a href="#通用爬虫" class="headerlink" title="通用爬虫"></a>通用爬虫</h4><p>  通用网络爬虫又称全网爬虫，爬行对象从一些种子 URL 扩充到整个 Web。主要用于搜索引擎。<br>通用网络爬虫的结构大致可以分为页面爬行模块 、页面分析模块、链接过滤模块、页面数据库、URL 队列、初始 URL 集合几个部分。为提高工作效率，通用网络爬虫会采取一定的爬行策略。</p>
<h4 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h4><p>  又称主题网络爬虫，选择性地爬行那些与预先定义好的主题相关页面的网络爬虫。聚焦网络爬虫和通用网络爬虫相比，增加了链接评价模块以及内容评价模块。</p>
<h4 id="增量爬虫"><a href="#增量爬虫" class="headerlink" title="增量爬虫"></a>增量爬虫</h4><p>  增量式网络爬虫是指对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。</p>
<h4 id="深度爬虫"><a href="#深度爬虫" class="headerlink" title="深度爬虫"></a>深度爬虫</h4><p> Web 页面按存在方式可以分为表层网页和深层网页。表层网页是指传统搜索引擎可以索引的页面，以超链接可以到达的静态网页为主构成的 Web 页面。Deep Web 是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的 Web 页面。自动填写表单，爬取深层网页是深度爬虫的任务。</p>
]]></content>
      
        <categories>
            
            <category> 编程实用技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
